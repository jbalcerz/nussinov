\subsection{Zrealizowane testy}
Zrealizowane zostały cztery tak zwane testy typu ,,black box'': dwa testy czasu wykonania programu, profilowanie kodu linijka po linijce oraz profilowanie pamięci wykorzystywanej przez program:
\begin{itemize}
\item timeTest.py - testowanie czasu wykonania, korzysta z pomocniczej klasy Timer;
\item timetest.sh - oszacowanie czasu wykonania programu z wykorzystaniem standardowej UNIX komendy time;
\item line_profiler_script.sh - profilowanie kodu linijka po linijce;
\item memory_profiler_script.sh - profilowanie pamięci wykorzystywanej programem.

\end{itemize}

\subsection{Kontrola wydajności kodu linijka po linijce}
Dla testowania wydajności kodu skorzystaliśmy z profilera autorstwa Roberta Kerna \cite{bib:Kern}. Za pomocą tego narzędzia można zobaczyć jak szybko i jak często wykonywana jest każda linijka kodu w naszym skrypcie. Żeby móc korzystać z line_profiler, najpierw należy go zainstalować:
 
                pip install line_profiler


Zainstalowane zostaną: moduł "line_profiler" oraz skrypt "kernprof.py". Dla testowania kodu korzysta się z dekoratora "@profile", który należy ustawić przed interesującymi nas funkcjami. Nic więcej nie potrzeba importować, ponieważ skrypt kernprof.py samodzielnie wkleja potrzebny kod w trakcie uruchomienia naszego skryptu. 
Po uruchomieniu skryptu line_profiler_script.sh odbywa się testowanie interesujących nas funkcji. Wyniki testu zostają zapisane do pliku line_profiler_test.txt. 

\subsection{Profiler pamięci}
Na podstawie profilera Roberta Kerna\cite{bib:Kern}, Fabian Pedregose stworzył profiler pamięci memory_profiler \cite{bib:mem}, który też cechuje się prostym i niezawodnym działaniem. Z danego profilera korzysta się, aby sprawdzić ilość pamięci wykorzystywanej przez  dany program. Żeby móc korzystać z memory_profiler, musimy go zainstalować: 

                    pip install -U memory_profiler
                         pip install psutil
                         
                         
Instalujemy także psutil (skutkuje on lepszą wydajnością profilera). Dla testowania kodu również korzystamy z dekoratora "@profile", którego ustawiamy przed interesującymi nas funkcjami.  Po uruchomieniu skryptu memory_profiler_script.sh odbywa się testowanie interesujących nas funkcji. Wyniki testowania zostają zapisane do pliku memory_profiler_test.txt. 

\subsection{Testy różnych sekwencji}

Poniżej przedstawione są wyniki działania skryptów testowych dla 2 różnych sekwencji: 
\begin{itemize}

\item GGGAAAAAACCC

timeTest.py

=> elapsed time: 1.95107889175 s

timetest.sh

real	0m2.409s
user	0m0.503s
sys	0m0.112s                                   


\item GUGAACCUGGCGGCGUGCCUAAUACAUGCAAGUCGAACGAUGAAGUCCUAGCUUGCUAGGAUGGAUUAGUGGCGCACGGGUGAGUAAUGUAUAGCUAAUCUGCCCCAUAGAGAGGAACAACACUUAGAAAUGAGUGCUAAUACCUCAUACUCCAAUUAUACAUAAGUUUAAUUGGGAAAUGUAGCUCUUAAUAAUAUAUAUCAAAGAUAAUUUAUAAAUAAAAAGUUAUAAAUAUAACAAUAAGCUUUUUUGAAGCUUUAUAUUAAUAAAGCGAAAAAAAAGCAAAGCAGUUAGAUUUAAUAAAUUUUUAUAGCAUUUAAAAAUACAAAAGACUUAAUUUUUAAAUCUAAAUAUAAAUUAUUACUAAUAUUUUUAAUAGGCAGAAAUGUUAAGACAGGUGCUGCACGGCUGUCGUCAGCUCGUGUCGUGAGAUGUUGGGUUAAGUCCCGCAACGAGCGCAACCCACGUGUUUAGUUGCUAACAGUUAGGCUGAGCACUCUAAACAGACUGCCUUCGUAAGGAGGAGGAAGGUGUGGACGACGUCAAGUCAUCAUGGCCCUUAUGUCCGGGGCGACACACGUGCUACAAUGGCAUAUACAAUAAGACGCAAUAUCGCGAGAUGGAGCAAAUCUAUAAAAUAUGUCCCAGUUCGGAUUGGAGUCUGCAACUCGACUCCAUGAAGCCGGAAUCGCUAGUAAUCGUAGAUCAGCCAUGCUACGGUGAAUACGUUCCCGGGUCUUGUACUCACCGCCCGUCACACCAUGGGAGUUGAUUUCACUCGAAGCCCAAAUACCAAAUUGGUUAUGGUCCACAGUGGAAUCAGCGACUGGGGUGAAGUCGUAACAAGGUAACCGUAGGAGAAC

timeTest.py

=> elapsed time: 49.3690121174 s

timetest.sh

real	0m45.319s
user	0m42.562s
sys	0m0.235s

\end{itemize}
