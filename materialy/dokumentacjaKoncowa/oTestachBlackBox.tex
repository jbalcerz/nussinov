\subsection{Zrealizowane testy}
Zrealizowane zostały 4 tak zwane testy “czarnej skrzynki”: 2 testy czasu wykonania programu, profilowanie kodu linijka po linijce a także profilowanie pamięci wykorzystywanej programem:
1. timeTest.py - nasza wersja testowania czasu wykonania, korzysta z pomocniczej klasy Timer;
2. timetest.sh - oszacowanie czasu wykonania programu z wykorzystaniem standardowej UNIX komendy time;
Inne dwa testujące skrypty są bardziej skomplikowane. Szczegóły pracy z tymi skryptami są zamieszczone w poszczególnych skryptach:
3. line_profiler_script.sh - profilowanie kodu linijka po linijce;
4. memory_profiler_script.sh - profilowanie pamięci wykorzystywanej programem.

\subsection{Profiler linijka po linijce}
Dla testowania wydajności kodu skorzystaliśmy się z profilera Roberta Kerna (https://pythonhosted.org/line_profiler/). Za pomocą tego narzędzia można zobaczyć jak szybko i jak często wykonywana jest każda linijka kodu w naszym skrypcie. Żeby móc korzystać z line_profiler, najpierw musimy go zainstalować: 
                pip install line_profiler
Zainstalowane zostaną moduł "line_profiler" oraz skrypt "kernprof.py". Dla testowania kodu korzystamy z dekoratora "@profile", którego ustawiamy przed interesującymi nas funkcjami. Nic więcej nie potrzebno importować, ponieważ skrypt kernprof.py samodzielnie wkleja potrzebny kod w trakcie uruchomienia naszego skryptu. 
Po uruchomieniu skryptu line_profiler_script.sh odbywa się testowanie interesujących nas funkcji. Wyniki testowania zostają zapisane do pliku line_profiler_test.txt. 

\subsection{Profiler pamięci}
Na podstawie profilera Roberta Kerna przez Fabiana Pedregosę został stworzony profiler pamięci memory_profiler (https://github.com/fabianp/memory_profiler), który też cechuje się prostym i niezawodnym działanie. Korzystamy z danego profilera żeby przetestować ilość pamięci, wykorzystywanej przez zaimplementowany nami skrypt. Żeby móc korzystać z memory_profiler, musimy go zainstalować: 

                    pip install -U memory_profiler
                         pip install psutil
Instalujemy także psutil, co sprawi lepszą wydajność profilera. 
Dla testowania kodu również korzystamy z dekoratora "@profile", którego ustawiamy przed interesującymi nas funkcjami. Nic więcej nie potrzebno importować. Po uruchomieniu skryptu memory_profiler_script.sh odbywa się testowanie interesujących nas funkcji. Wyniki testowania zostają zapisane do pliku memory_profiler_test.txt. 

\subsection{Testy dla różnych sekwencji}

Poniżej przedstawione są wyniki działania skryptów testowych dla 2 różnych sekwencji: 

1. GGGAAAAAACCC

timeTest.py

=> elapsed time: 1.95107889175 s

timetest.sh

real	0m2.409s
user	0m0.503s
sys	0m0.112s                                   


2. GUGAACCUGGCGGCGUGCCUAAUACAUGCAAGUCGAACGAUGAAGUCCUAGCUUGCUAGGAUGGAUUAGUGGCGCACGGGUGAGUAAUGUAUAGCUAAUCUGCCCCAUAGAGAGGAACAACACUUAGAAAUGAGUGCUAAUACCUCAUACUCCAAUUAUACAUAAGUUUAAUUGGGAAAUGUAGCUCUUAAUAAUAUAUAUCAAAGAUAAUUUAUAAAUAAAAAGUUAUAAAUAUAACAAUAAGCUUUUUUGAAGCUUUAUAUUAAUAAAGCGAAAAAAAAGCAAAGCAGUUAGAUUUAAUAAAUUUUUAUAGCAUUUAAAAAUACAAAAGACUUAAUUUUUAAAUCUAAAUAUAAAUUAUUACUAAUAUUUUUAAUAGGCAGAAAUGUUAAGACAGGUGCUGCACGGCUGUCGUCAGCUCGUGUCGUGAGAUGUUGGGUUAAGUCCCGCAACGAGCGCAACCCACGUGUUUAGUUGCUAACAGUUAGGCUGAGCACUCUAAACAGACUGCCUUCGUAAGGAGGAGGAAGGUGUGGACGACGUCAAGUCAUCAUGGCCCUUAUGUCCGGGGCGACACACGUGCUACAAUGGCAUAUACAAUAAGACGCAAUAUCGCGAGAUGGAGCAAAUCUAUAAAAUAUGUCCCAGUUCGGAUUGGAGUCUGCAACUCGACUCCAUGAAGCCGGAAUCGCUAGUAAUCGUAGAUCAGCCAUGCUACGGUGAAUACGUUCCCGGGUCUUGUACUCACCGCCCGUCACACCAUGGGAGUUGAUUUCACUCGAAGCCCAAAUACCAAAUUGGUUAUGGUCCACAGUGGAAUCAGCGACUGGGGUGAAGUCGUAACAAGGUAACCGUAGGAGAAC

timeTest.py

=> elapsed time: 49.3690121174 s

timetest.sh

real	0m45.319s
user	0m42.562s
sys	0m0.235s


